jsx的事件绑定
```
render(){
    return  <button className='btn btn-success' onClick={this.support}>支持</button>
    //this.support.bind(this) 改变this
}
 support(ev){
       //=>this:undefined(不是我们理解的当前操作的元素)
       //=>ev.target:通过事件源可以获取当前操作元素（一般很少操作，因为框架主要是数据驱动所有dom的改变）
    }
  support=ev=>{
      //=>this:继承上下文中的this（实例），真实项目中，给jsx元素绑定的事件方法一般都是箭头函数，目的是为了保证函数中的this还是实例；
  }
  ```
<span rel=x=>this.spanLeft=x></span>
//=>x代表当前元素，它的意思是，把当前元素直接挂载在实例上，后期需要用到元素，直接this.spanLeft获取即可
  ```
===========
在react组件中
1.基于数据驱动（修改状态数据，react帮助我们重新渲染视图）完成的组件叫做“受控组件”（受数据控制的组件）“
2.基于ref操作dom实现视图更新的，叫做“非受控组件”;
=>真实项目中，建议大家多使用“受控组件”；

============
vue ：[mvvm] 数据更改视图跟着更改，视图更改数据也跟着更改（双向数据绑定）
react：[mvc] 数据更改视图跟着更改（原本是单数据绑定，但是我们自己可以构建出双向的效果）
============
onChange实现mvvm

=================
生命周期函数（钩子函数）
  描述一个组件或者程序从创建到销毁的过程，我们可以在过程中间基于钩子函数完成一些自己的操作（例如：在第一次渲染完成做什么，或者在二次即将重新渲染之前做什么等...)
  [基本流程]
    constructor 创建一个组件
    componentWillMount 第一次渲染之前
    render 第一渲染
    componentDidMount 第一次渲染之后
    [修改流程：当组件的状态数据发生改变（set-state）或者传递给组件的属性发生改变（重新调用组件传递不同的属性）会引发render重新执行渲染（渲染也是差异渲染）]
    shouldComponentUpdate 是否允许组件重新渲染（允许则执行后面函数，不允许直接结束即可）
    componentWillUpdate 重新渲染之前
    render 第二次及以后重新渲染
    componentDidUpdate
    componentWillReceiveProps：父组件把传递给子组件的属性发生改变后触发的钩子函数
    [卸载：原有渲染的内容是不消失的，之不过以后不能基于数据改变视图了]
    componentWillUnmount
=========================================================================


父组件把信息传递给子组件
  基于属性传递即可（而且是单方向的：只能父亲通过属性信息给儿子，儿子不能传递给父亲）
  后期子组件中的信息需要修改：可以让父组件传递给子组件的信息发生变化（也就是子组件接受的属性值发生变化，子组件也会重新渲染=》componentWillReceiveProps钩子函数）
  只要实现。点击子组件body按钮的时候，可以修改父组件panel的状态信息，panel的状态改变，panel串、会重新执行render渲染，会重新执行render，会把最新的状态值作为属性，传递给子组件head，head接受的属性值发生改变，head组件也会重新渲染。
    类似于这种“子改父”的操作，我们需要使用以下技巧完成
     1.把父组件中的一个方法，作为属性传递给子组件
     2.在子组件中，把基于属性传递进来的方法，在适合的时候执行（相当于执行父组件中的方法：而这个方法中完全可以操作父组件中信息）